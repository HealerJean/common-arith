package com.hlj.arith.demo00011时分秒问题;

/**
 * 作者：HealerJean
 * 题目：24小时内，时针和分针 一共重叠了几次，以及重叠的时间点
 * 解题思路：
 * 虽然分针走一圈,会和时针重叠一次,但是分针走的时候,时针并不是静止不动的；
 * 原来分针每走12圈,时针自己也要走一圈；因此,对时针来说,分针只绕时针走了11圈.
 * 当分针走了24圈的时候,时针也走了2圈；因此,分针绕时针只走了22圈,所以只重叠22次.
 * <p>
 * 脑海中想象，分针和时针的画面 ，
 * 从0点一开开始，有第1次重叠，
 * 0点到1点，重叠 1 次
 * ……	……
 * 11点到12点，会发现没有重叠。
 * 那么这是在12个小时内的。12个小时重叠了11次，也就是说24小时会重叠22次
 * <p>
 * 答案：
 * 1、所以算上起点时重合的一次，分针会遇上时针23次。
 * 2、请看下面的算法
 * <p>
 * 1小时 = 60 分钟， 1分钟= 60秒
 * 1小时 = 60 * 60 = 3600 秒
 * <p>
 * <p>
 * 一小时 = 360/12 = 30度  ； 时针一分钟走  30度/60分钟  = 0.5度/分钟 ，时针一秒钟走0.5度/60秒 度/秒
 * 一分钟 = 30/5   = 6度   									      分钟一秒钟走 6度/60秒  度/秒
 * 一秒  = 30/5   = 6度
 */
public class TestMain {


    public static void main(String[] args) {
        int count = 0;
        for (int h = 1; h <= 12; h++) { //h是小时
            for (int m = 0; m <= 60; m++) {//m是分针
                double hDu = h * 30 + m * 0.5; // 时针一共走的度数 （从00.00开始走的度数）
                double mDu = m * 6; // 分针走过的度数

                //时针和分针相差的度数,重合的合时候的夹角不会超过一分钟走的6度
                //我们可以自己脑子中想象，在每个小时内，时针永远在分针后面追赶时针。所以时针走的度数肯定比分针走的度数大
                double hmDu = (hDu - mDu);
                if (0 < hmDu && hmDu < 6.0) {

                    System.out.println(h + "小时:" + m + "分");
                    count++;
                }
            }
        }
        System.out.println("一共重叠" + count);

    }


    /**

     1:5
     2:10
     3:16
     4:21
     5:27
     6:32
     7:38
     8:43
     9:49
     10:54
     11:59 //应该是12：00
     13:5
     14:10
     15:16
     16:21
     17:27
     18:32
     19:38
     20:43
     21:49
     22:54
     23:59 应该是24：00
     共重合：22次
     */


}
